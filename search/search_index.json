{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TwPM documentation About Trust worthy Platform Module project aims to increase the trustworthiness of the traditional TPM module (hence the T w PM), by providing the open-source firmware implementation for the TPM device, compliant to the TCG PC Client Specification . The main goal of the project is an attempt to create open-source firmware stack, implementing the TCG PC Client Platform TPM Profile specification. Project aims to use already available open-source software components whenever possible (such as TPM simulators for TPM commands handling), while developing new code when necessary (such as LPC FPGA module, or low-level TPM FIFO interface handling). Another challenge is to overcome hardware restrictions and allow users to use the open-source TPM implementation on generally-accessible development boards. Community TwPM project is a project of the Dasharo community. It\u2019s an open-source project that welcomes community contributions, suggestions, fixes, and other form of feedback. Join Dasharo Matrix Community Join TwPM channel in Dasharo Matrix space How to contribute Roadmap Funding This project was partially funded through the NGI Assure Fund, a fund established by NLnet with financial support from the European Commission's Next Generation Internet programme, under the aegis of DG Communications Networks, Content and Technology under grant agreement No 957073.","title":"Index"},{"location":"#twpm-documentation","text":"","title":"TwPM documentation"},{"location":"#about","text":"Trust worthy Platform Module project aims to increase the trustworthiness of the traditional TPM module (hence the T w PM), by providing the open-source firmware implementation for the TPM device, compliant to the TCG PC Client Specification . The main goal of the project is an attempt to create open-source firmware stack, implementing the TCG PC Client Platform TPM Profile specification. Project aims to use already available open-source software components whenever possible (such as TPM simulators for TPM commands handling), while developing new code when necessary (such as LPC FPGA module, or low-level TPM FIFO interface handling). Another challenge is to overcome hardware restrictions and allow users to use the open-source TPM implementation on generally-accessible development boards.","title":"About"},{"location":"#community","text":"TwPM project is a project of the Dasharo community. It\u2019s an open-source project that welcomes community contributions, suggestions, fixes, and other form of feedback. Join Dasharo Matrix Community Join TwPM channel in Dasharo Matrix space How to contribute Roadmap","title":"Community"},{"location":"#funding","text":"This project was partially funded through the NGI Assure Fund, a fund established by NLnet with financial support from the European Commission's Next Generation Internet programme, under the aegis of DG Communications Networks, Content and Technology under grant agreement No 957073.","title":"Funding"},{"location":"changelog/","text":"Changelog 2024-03-14 Added testbench outputs to Verilog modules Added SPI module description Reset signal was added to the registers module, required because SPI clock isn't free-running. Added instructions for connecting to mainboard through SPI Fixed broken links here and in Development/Testing Fixed command for running tests in Development/Testing (missing asterisks) Published tests results as part of Task 7. Implement SPI TPM protocol Updated FPGA utilisation numbers 2024-01-16 Added page about running tests Published tests results as part of Task 6. Base tests Small changes to description of interrupts handling 2023-11-26 Reduce numbers of bi-directional lines to minimum (Yosys doesn't like them) Switch to OrangeCrab Reason Updated building instructions - actual instructions moved to README in top level repository to avoid duplications Modified memory map New FPGA utilization numbers Instructions for connecting TwPM to mainboard - Protectli VP46xx Description of new modules (NEORV32, LiteDRAM, TPM buffer) 2023-07-31 Added Blog post on optimizing SPI communitation on STM32 Information on maximum real SPI frequency on STM32 in the hardware selection section 2023-05-24 Added New Verilog Module specification in Development section , added graphics and links to modules' code Fixed broken links in changelog (here) and Development section First implementation details documented Update statuses on the roadmap 2023-04-20 Added Hardware requirements in Explanation section Hardware selection in Explanation section Building TwPM in Tutorials section Verilog Modules specification in Development section","title":"Index"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#2024-03-14","text":"Added testbench outputs to Verilog modules Added SPI module description Reset signal was added to the registers module, required because SPI clock isn't free-running. Added instructions for connecting to mainboard through SPI Fixed broken links here and in Development/Testing Fixed command for running tests in Development/Testing (missing asterisks) Published tests results as part of Task 7. Implement SPI TPM protocol Updated FPGA utilisation numbers","title":"2024-03-14"},{"location":"changelog/#2024-01-16","text":"Added page about running tests Published tests results as part of Task 6. Base tests Small changes to description of interrupts handling","title":"2024-01-16"},{"location":"changelog/#2023-11-26","text":"Reduce numbers of bi-directional lines to minimum (Yosys doesn't like them) Switch to OrangeCrab Reason Updated building instructions - actual instructions moved to README in top level repository to avoid duplications Modified memory map New FPGA utilization numbers Instructions for connecting TwPM to mainboard - Protectli VP46xx Description of new modules (NEORV32, LiteDRAM, TPM buffer)","title":"2023-11-26"},{"location":"changelog/#2023-07-31","text":"","title":"2023-07-31"},{"location":"changelog/#2023-05-24","text":"","title":"2023-05-24"},{"location":"changelog/#2023-04-20","text":"","title":"2023-04-20"},{"location":"contributing/","text":"Page is under construction Page is under construction","title":"Index"},{"location":"contributing/#page-is-under-construction","text":"Page is under construction","title":"Page is under construction"},{"location":"development/","text":"Development This section of documentation contains reference material for those interested in developing and contributing to the TwPM project. Document Goal Verilog modules Learn the specification of the existing Verilog modules, so you can contribute Communication between SoC and FPGA Learn how SoC communicates with FPGA in this project","title":"Index"},{"location":"development/#development","text":"This section of documentation contains reference material for those interested in developing and contributing to the TwPM project. Document Goal Verilog modules Learn the specification of the existing Verilog modules, so you can contribute Communication between SoC and FPGA Learn how SoC communicates with FPGA in this project","title":"Development"},{"location":"development/soc_fpga_communication/","text":"Communication between SoC and FPGA This document describes how FPGA and SoC communicate with each other in TwPM project for NEORV32. State presented here is valid for release v0.2.0 of top module. Memory map Address Size Name Access 0xF0000000 4B STATUS RO 0xF0000004 4B OP_TYPE RO 0xF0000008 4B LOCALITY RO 0xF000000C 4B BUF_SIZE RO 0xF0000040 4B COMPLETE WO 0xF0000800 2KiB FPGA_RAM RW Reads from invalid addresses in 0xF0000000-0xF0000FFF range return 0xBADFABAC (BAD FABric ACcess), writes are dropped. Most values are valid only if exec bit in STATUS register is set. Registers Reserved bits are read as 0. They may change in the future. STATUS exec indicates that MCU is expected to act upon request sent from FPGA, specified in OP_TYPE register. Interrupt is generated when this signal gets set by FPGA. abort is set when PC aborts command currently being executed by TPM. complete is a signal sent towards FPGA by writing to COMPLETE register. The signal is active for a few cycles after write to that register, after that is should be automatically set back to 0. OP_TYPE op_type is a type of operation expected from MCU. 0 is used as a default value to which this register returns after complete signal is acknowledged by FPGA, code should treat this value as error because no valid path produces it when requesting interaction from MCU. 0xC is reserved as it may be part of 0xBADFABAC magic value. This register is only valid if exec is set. op_type Operation 0x0 No operation 0x1 Execute TPM2 command located in FPGA_RAM 0xC Illegal operation type other Reserved for future use LOCALITY locality specifies the locality at which the current operation was initiated. Value 0xF is used when no locality was active at that point. This field is only valid if exec is set. BUF_SIZE buf_size specifies size (in bytes) of data available in FPGA RAM, which is usually a TPM2 command. This field is only valid if exec is set. TPM stack is not expected to write size of response to this field, it is deduced from response's payload. COMPLETE Any write to this register triggers complete signal to be sent to FPGA. Reads from this register aren't implemented, meaning that 0xBADFABAC is returned. FPGA RAM This region behaves like RAM if exec is set. Its content depends on op_type , which in most cases will be TPM2 command. Response is written by MCU to this buffer, starting from offset 0, overwriting the command. When exec is not set, data read from this region is invalid and writes are dropped. Interrupts TwPM needs to communicate from FPGA towards SoC when there is an operation to be performed by TPM stack. This is done through mext_irq_i , which is responsible for signaling Machine external interrupt (MEI). This signal is level-triggered and high-active. MEI has a dedicated value in mcause , shared between all external interrupts. The exact reason has to be obtained in a platform-specific way; in case of TwPM it can be read from STATUS register, however, as of now only exec generates an interrupt so this check is redundant. The interrupt signal remains active until SoC signals completion by performing a write to COMPLETE register. For this reason, the IRQ must be masked when TPM command is being executed outside of interrupt service routine (ISR).","title":"Communication between SoC and FPGA"},{"location":"development/soc_fpga_communication/#communication-between-soc-and-fpga","text":"This document describes how FPGA and SoC communicate with each other in TwPM project for NEORV32. State presented here is valid for release v0.2.0 of top module.","title":"Communication between SoC and FPGA"},{"location":"development/soc_fpga_communication/#memory-map","text":"Address Size Name Access 0xF0000000 4B STATUS RO 0xF0000004 4B OP_TYPE RO 0xF0000008 4B LOCALITY RO 0xF000000C 4B BUF_SIZE RO 0xF0000040 4B COMPLETE WO 0xF0000800 2KiB FPGA_RAM RW Reads from invalid addresses in 0xF0000000-0xF0000FFF range return 0xBADFABAC (BAD FABric ACcess), writes are dropped. Most values are valid only if exec bit in STATUS register is set.","title":"Memory map"},{"location":"development/soc_fpga_communication/#registers","text":"Reserved bits are read as 0. They may change in the future.","title":"Registers"},{"location":"development/soc_fpga_communication/#fpga-ram","text":"This region behaves like RAM if exec is set. Its content depends on op_type , which in most cases will be TPM2 command. Response is written by MCU to this buffer, starting from offset 0, overwriting the command. When exec is not set, data read from this region is invalid and writes are dropped.","title":"FPGA RAM"},{"location":"development/soc_fpga_communication/#interrupts","text":"TwPM needs to communicate from FPGA towards SoC when there is an operation to be performed by TPM stack. This is done through mext_irq_i , which is responsible for signaling Machine external interrupt (MEI). This signal is level-triggered and high-active. MEI has a dedicated value in mcause , shared between all external interrupts. The exact reason has to be obtained in a platform-specific way; in case of TwPM it can be read from STATUS register, however, as of now only exec generates an interrupt so this check is redundant. The interrupt signal remains active until SoC signals completion by performing a write to COMPLETE register. For this reason, the IRQ must be masked when TPM command is being executed outside of interrupt service routine (ISR).","title":"Interrupts"},{"location":"development/testing/","text":"Testing Overview This document presents the current status and progress of testing the TwPM module features. The tests used here are located in the Dasharo OSFV repository . Tests results The latest results (as of 14/03/2024) can be found here . It was run on Protectli VP6670, TwPM was connected through SPI interface. Previous version (running on LPC) is available here . Hardware setup Hardware list Orange Crab The TwPM is implemented on this board One of: Protectli VP4670 , the TwPM is connected to LPC TPM header on this board Protectli VP6670 , the TwPM is connected to SPI TPM header on this board Connection to the platform Follow the mainboard connection tutorial . In case of LPC, make sure that LCLK and LAD lines aren't directly next to each other (e.g. separate those with GND), otherwise inter-signal noise would cause bad reads. No such interference was observed for SPI. Development connection The Orange Crab still requires reflashing over UART during testing, that is why the USB-UART converter must also be connected. Running tests Follow the Getting started section of test repository first Apply the following diff if not using RTE . Adjust OS credentials to your case. Follow that issue for progress on improving the testing experience with no additional hardware involved. Execute a selection of test: At the moment, CreatePrimary() is not supported, that is why tests using it are excluded from the suite. More information can be found in this issue . Replace $DEVICE_IP with the IP address of your device, where TwPM is connected. It is assumed running Ubuntu 22.04 OS with OpenSSH server enabled via password authentication. For this test suite, both VP4670 and VP6670 may use protectli-vp4670 configuration. robot -L TRACE -v device_ip: $DEVICE_IP -v config:protectli-vp4670 -v snipeit:no -t \"TPMCMD00[0-469]*\" -t \"TPMCMD010*\" dasharo-security/tpm2-commands.robot","title":"Testing"},{"location":"development/testing/#testing","text":"","title":"Testing"},{"location":"development/testing/#overview","text":"This document presents the current status and progress of testing the TwPM module features. The tests used here are located in the Dasharo OSFV repository .","title":"Overview"},{"location":"development/testing/#tests-results","text":"The latest results (as of 14/03/2024) can be found here . It was run on Protectli VP6670, TwPM was connected through SPI interface. Previous version (running on LPC) is available here .","title":"Tests results"},{"location":"development/testing/#hardware-setup","text":"","title":"Hardware setup"},{"location":"development/testing/#running-tests","text":"Follow the Getting started section of test repository first Apply the following diff if not using RTE . Adjust OS credentials to your case. Follow that issue for progress on improving the testing experience with no additional hardware involved. Execute a selection of test: At the moment, CreatePrimary() is not supported, that is why tests using it are excluded from the suite. More information can be found in this issue . Replace $DEVICE_IP with the IP address of your device, where TwPM is connected. It is assumed running Ubuntu 22.04 OS with OpenSSH server enabled via password authentication. For this test suite, both VP4670 and VP6670 may use protectli-vp4670 configuration. robot -L TRACE -v device_ip: $DEVICE_IP -v config:protectli-vp4670 -v snipeit:no -t \"TPMCMD00[0-469]*\" -t \"TPMCMD010*\" dasharo-security/tpm2-commands.robot","title":"Running tests"},{"location":"development/verilog_modules/","text":"Verilog modules Below is description of FPGA modules used by TwPM for OrangeCrab. The design may change as the project progresses, state described here is valid for revision marked with tag v0.2.0 of the top module. This document includes diagrams generated with Symbolator . On these diagrams, input ports are on the left, and outputs and bi-directional signals are on the right. Module parameters are at the top, on gray background. In general, clocks are marked with triangle inside, and active-low signals with circle outside of rectangle symbolizing the module. However, Symbolator makes a guess about signal function based only on its name, which in some cases gives wrong results. Such cases are mentioned in the signal descriptions under the diagrams. Current FPGA utilization for LPC: Info: Device utilisation: Info: TRELLIS_IO: 65/ 197 32% Info: DCCA: 5/ 56 8% Info: DP16KD: 5/ 56 8% Info: MULT18X18D: 1/ 28 3% Info: ALU54B: 0/ 14 0% Info: EHXPLLL: 1/ 2 50% Info: EXTREFB: 0/ 1 0% Info: DCUA: 0/ 1 0% Info: PCSCLKDIV: 0/ 2 0% Info: IOLOGIC: 44/ 128 34% Info: SIOLOGIC: 0/ 69 0% Info: GSR: 0/ 1 0% Info: JTAGG: 0/ 1 0% Info: OSCG: 0/ 1 0% Info: SEDGA: 0/ 1 0% Info: DTR: 0/ 1 0% Info: USRMCLK: 1/ 1 100% Info: CLKDIVF: 1/ 4 25% Info: ECLKSYNCB: 1/ 10 10% Info: DLLDELD: 0/ 8 0% Info: DDRDLL: 1/ 4 25% Info: DQSBUFM: 2/ 8 25% Info: TRELLIS_ECLKBUF: 3/ 8 37% Info: ECLKBRIDGECS: 1/ 2 50% Info: DCSC: 0/ 2 0% Info: TRELLIS_FF: 5049/24288 20% Info: TRELLIS_COMB: 12639/24288 52% Info: TRELLIS_RAMW: 121/ 3036 3% Current FPGA utilization for SPI: Info: Device utilisation: Info: TRELLIS_IO: 62/ 197 31% Info: DCCA: 6/ 56 10% Info: DP16KD: 5/ 56 8% Info: MULT18X18D: 0/ 28 0% Info: ALU54B: 0/ 14 0% Info: EHXPLLL: 1/ 2 50% Info: EXTREFB: 0/ 1 0% Info: DCUA: 0/ 1 0% Info: PCSCLKDIV: 0/ 2 0% Info: IOLOGIC: 44/ 128 34% Info: SIOLOGIC: 0/ 69 0% Info: GSR: 0/ 1 0% Info: JTAGG: 0/ 1 0% Info: OSCG: 0/ 1 0% Info: SEDGA: 0/ 1 0% Info: DTR: 0/ 1 0% Info: USRMCLK: 1/ 1 100% Info: CLKDIVF: 1/ 4 25% Info: ECLKSYNCB: 1/ 10 10% Info: DLLDELD: 0/ 8 0% Info: DDRDLL: 1/ 4 25% Info: DQSBUFM: 2/ 8 25% Info: TRELLIS_ECLKBUF: 3/ 8 37% Info: ECLKBRIDGECS: 1/ 2 50% Info: DCSC: 0/ 2 0% Info: TRELLIS_FF: 5025/24288 20% Info: TRELLIS_COMB: 12175/24288 50% Info: TRELLIS_RAMW: 121/ 3036 3% Top level Top level module code is located in this repository . It glues together other modules, which are referenced by that repository as git submodules. It also describes how the signals are connected to external IO pins. Top level module parameters: TPM_RAM_* , TPM_REGS_* , TPM_REG_* : those specify addresses and sizes used in Communication between SoC and FPGA . LITEDRAM_* and RAM_* : LiteDRAM controller and main (DDR3) RAM base address and size. DEFAULT_READ_VALUE : value read from TPM_REGS region outside of any defined register. COMPLETE_PULSE_WIDTH : width (in system clock cycles) of complete signal. See TPM registers module description for details on that signal. External ports: clk_i : input (crystal) clock running at 48 MHz. Note that it is only used for driving PLL, which in turn generates 50 MHz clock for most of the system. rstn_i : asynchronous reset signal, active low. It is converted to synchronous reset that is used for most of the components. (Note: it is not marked as negated on the diagram due to how Symbolator detects such signals, i.e. its name doesn't end with either _n or _b ). uart_rxd_i , uart_txd_o : UART running at 115200n8. LPC interface: those are to be connected to the mainboard, see Connecting TwPM to mainboard . Note that only one of LPC or SPI interface is present at any given time, depending on build configuration. SPI interface: those are to be connected to the mainboard, see Connecting TwPM to mainboard . Note that only one of LPC or SPI interface is present at any given time, depending on build configuration. SPI flash signals: connected to onboard SPI flash. Note that there is no clock signal on the diagram, a hardware macro must be used instead of defining it as a port. DDR3 interface: signals to and from onboard DRAM, connected directly to LiteDRAM module. Negative part of differential signals (CK, DQS) are implemented with hardware macros, so they are not listed as I/O ports. led_r , led_g , led_b : outputs driving RGB LED. All of them are active low (this is how LEDs usually work), even though only one of them is marked as such (again, due to how Symbolator parses names). NEORV32 The NEORV32 processor is used to run software TPM stack on. It is highly configurable, and many of its modules are disabled in TwPM, so not all of the Processor top entity signals are used. clk_i , rstn_i : main clock and reset signals. Note that these are not the top level clock and reset, instead these are outputs from LiteDRAM described below. This clock runs at 50 MHz. Reset is active-low, but Symbolator didn't represent it correctly on diagram. uart0_rxd_i , uart0_txd_o : main UART, connected directly to I/O pads. JTAG signals: unused for now. WISHBONE bus interface: configured as WISHBONE Classic. Used for accessing modules external to the processor, like TPM module, DRAM and LiteDRAM controller. SPI interface: connected to top level I/O either directly or through hardware macro ( spi_clk_o ). GPIO: only 3 outputs are connected to LEDs to provide some kind of output even if UART is not connected. Inputs are hardwired to 0 because there is no way of implementing just the outputs. LiteDRAM While the module was generated with LiteDRAM , the entire source is included in TwPM_toplevel repository , along with configuration file used to create it. This is done to make the code reproducible, as well as to add some customizations, listed in comment at the top of Verilog file. List of ports: clk , rst , user_clk and user_rst : this module implements PLL and reset synchronizer, these are respective inputs and outputs for them. On input we have 48 MHz clock and asynchronous reset, and on output 50 MHz clock with synchronous reset signal. Note that both reset signals are active-high , contrary to the rest of the project. Both are negated in top level module. DDR3 RAM signals: routed directly to top level module's ports. init_done , init_error , pll_locked : status signals, not really used in current implementation. First two are controlled by software doing the initialization, and the user_rst is active until PLL is locked, which in turn doesn't release NEORV32 core. pll_locked is connected to blue LED as a sign of life. RAM WISHBONE interface: WISHBONE Classic interface for accessing the main memory. Mostly standard, except for user_port_wishbone_adr - it specifies (4 bytes) word address, not byte address. Its width is also limited to the size of RAM. Controller WISHBONE interface: also a WISHBONE Classic interface, used to set up and initialize RAM before it is usable. Refer to the LiteDRAM and liblitedram (which for some reason is in main LiteX repository) for details on how to interact with it. wb_ctrl_adr is also using word addresses as above, but its width is not limited otherwise. Only lower bits are compared in the module, which means that top level has to arbitrate other signals (e.g. CYC or STB) to avoid aliasing. LPC module Source code: Dasharo/verilog-lpc-module Testbench results: VCD info: dumpfile lpc_periph_tb.vcd opened for output. Performing TPM write w/o delay Performing TPM write with delay Performing TPM read with delay Performing TPM read w/o delay Testing reset behaviour - TPM write w/o delay Testing reset behaviour - TPM read w/o delay Testing reset behaviour - TPM write with delay Testing reset behaviour - TPM read with delay Testing non-TPM transactions Testing extended LFRAME# timings - write Testing extended LFRAME# timings - read Testing abort mechanism - write Testing abort mechanism - read Testing interrupts - Continuous mode: no interrupt reported when not requested? proper IRQ reported? IRQ number latched at start frame? IRQ keeps being sent while active? IRQ stops being sent when no longer active? recovery and turn-around phases executed when int is deactivated? IRQs reported with idle clock cycles before stop frame? IRQs reported with idle clock cycles after stop frame? IRQs reported with longer start pulse width? Testing interrupts - switching between modes: peripheral doesn't initialize SERIRQ cycle in Quiet mode when not needed? peripheral initializes SERIRQ cycle when IRQ needed in Quiet mode? reset switches peripheral to Continuous mode? Testing interrupts - Quiet mode: proper IRQ reported? IRQ number latched at start frame? IRQ keeps being sent while active? IRQ stops being sent when no longer active? recovery and turn-around phases executed when int is deactivated? IRQs reported with idle clock cycles before stop frame? peripheral keeps working after spurious interrupt? IRQs reported with longer start pulse width? Testing interrupts - IRQ stops being reported on reset lpc_periph_tb.v:1344: $stop called at 518601000 (1ps) This module is responsible for managing LPC communication. It responds only to TPM cycles, other cycle types are ignored. SERIRQ (both continuous and quiet mode), cycle aborts and LPC resets are implemented. Ports for LPC interface (refer to LPC specification for details): clk_i : LPC clock. nrst_i : LPC reset (active low). lframe_i : LPC frame input (active low). lad_bus : LPC data bus, slow pull-up on host side. serirq : LPC SERIRQ signal, slow pull-up on host side. More information about SERIRQ can be found here . Ports for signals to/from data provider: lpc_addr_o : 16-bit address of TPM register. lpc_data_i : data received from data provider (TPM registers module) to be sent to host. lpc_data_o : data received from host to be sent to TPM registers module. lpc_data_wr : signal to data provider that lpc_addr_o and lpc_data_o have valid data and write is requested. lpc_wr_done : signal from data provider that lpc_data_o has been read. This signal should be driven until LPC module stops driving lpc_data_wr , after which this signal should be stopped being driven no later than 1 clk_i cycle (30ns). LPC module changes lpc_data_wr on falling clk_i edge so it is suggested that data provider module samples that signal on rising edge. lpc_data_req : signal to data provider that data is requested (rising edge of this signal) or has been read (falling edge) from lpc_data_i . lpc_data_req is changed on falling edge of clk_i . lpc_data_rd : signal from data provider that lpc_data_i has valid data for reading. This signal should be driven in response to lpc_data_req . lpc_data_rd is sampled by LPC module on falling clk_i edge. This signal should be driven until LPC module stops driving lpc_data_req , after which this signal should be stopped being driven no later than 1 clk_i cycle (30ns). LPC module changes lpc_data_req on falling clk_i edge so it is suggested that data provider module samples that signal on rising edge. irq_num : IRQ (interrupt request) number, for TPM this is configured by TPM_INT_VECTOR_x.sirqVec (see TCG PC Client Platform TPM Profile Specification for TPM 2.0 chapter 6.6.1.3). No parsing is done by LPC module, meaning that both IRQ0 (which in some, but not all parts of TPM specification this means \"IRQ disabled\") and IRQ2 (SMI) are valid. IRQ number is sampled on clk_i falling edge on SERIRQ start frame, turn-around phase. This is done to avoid sending one interrupt with two different IRQ numbers in one cycle. interrupt : whether interrupt should be signaled to host to which TwPM is connected, active high. It is checked at the beginning of SERIRQ frame of IRQ latched from irq_num , both in quiet and continuous mode. In addition to that, in quiet mode this signal initializes SERIRQ cycle. Data provider should drive this signal as long as reason for interrupt is valid. SPI module Source code: Dasharo/verilog-spi-module Testbench results: VCD info: dumpfile spi_periph_tb.vcd opened for output. Performing TPM write w/o delay Performing TPM write with delay Performing TPM read with delay Performing TPM read w/o delay Testing transfers with scattered clock between bytes Testing over-sized transfers Testing non-TPM addresses Testing crossing registers boundary spi_periph_tb.v:349: $stop called at 86540000 (1ps) This module is responsible for managing SPI communication with PC. It only supports SPI protocol as described in TPM specification. Ports for SPI interface: clk_i : SPI clock. cs_n : Chip select (active low). mosi : SPI Main Out Sub In. miso : SPI Main In Sub Out, slow pull-up on host side. Ports for signals to/from data provider: addr_o : 16-bit address of TPM register. data_i , data_o : data received from or sent to TPM registers module. data_wr : signal to data provider that addr_o and data_o have valid data and write is requested. wr_done : signal from data provider that data_o has been read. This signal isn't used by SPI module because it would most likely arrive when the clock is no longer running. Contrary to the LPC, SPI clock runs only during the transmission. data_req : signal to data provider that data is requested. data_rd : signal from data provider that data_i has valid data for reading. This signal should be driven in response to data_req . Note that there are no signals responsible for interrupts. SPI uses PIRQ, which doesn't require any additional logic, so interrupt signal from TPM registers module is used to drive it directly in the top level module. TPM registers module Source code: Dasharo/verilog-tpm-fifo-registers Testbench results: VCD info: dumpfile regs_tb.vcd opened for output. Testing simple register reads without delay Testing simple register reads with delay Checking register values against expected.txt Checking if RO registers are writable Testing mechanisms for changing locality Testing mechanisms for seizing locality Testing TPM_INT_VECTOR write without delay - proper locality Testing TPM_INT_VECTOR write with delay - proper locality Testing TPM_INT_VECTOR write without delay - wrong locality Testing TPM_INT_VECTOR write with delay - wrong locality Testing TPM_INT_VECTOR write without delay - no locality Testing TPM_INT_VECTOR write with delay - no locality Testing command/response exchange and TPM state machine - basic Testing command/response exchange and TPM state machine - advanced regs_tb.v:1075: $stop called at 2023220000 (1ps) This module implements TPM register space. It also handles locality transitions, TPM interrupt generation and command finite state machine. Register values are reported accordingly to the current state. Registers not defined by PC Client specification return 0xFF on reads, and writes are dropped. The module is located between host interface module (LPC or SPI) and memory buffer for TPM commands and responses. It also exposes hardware interface that is translated by top module into software interface for TPM stack running on NEORV32 processor. Ports for signals to/from LPC or SPI module: clk_i : LPC/SPI clock is used for this module to allow for synchronous communication with LPC/SPI module. Because of that, all registers' values are available in one clock cycle and no wait states (LPC) or exactly one wait state (SPI) has to be inserted. For LPC,the clock is free-running, but for SPI it is enabled only during the communication. reset : reset signal, required to reset registers to their initial values, active low. addr_i : 16-bit address of register to access. data_i : 8-bit data from LPC/SPI module. data_o : 8-bit data to LPC/SPI module. data_wr , wr_done , data_req , data_rd : 4 signals coordinating communication over data_i and data_o . Their functions can be found in the LPC module description or SPI module description above. irq_num , interrupt : configuration and request of interrupts sent to host, see LPC module description for details. In case of SPI, interrupt is negated and routed directly to I/O pin in top level and irq_num is not used. Note that these are not interrupts sent towards NEORV32. Ports for signals for MCU interface: op_type : type of operation requested from TPM stack. Currently only 0 (no operation) and 1 (execute TPM2 command located in TPM RAM) are used. locality : locality at which the operation was requested. buf_len : length of data (e.g. TPM2 command) in TPM RAM. exec : signal that all of the above are valid and TPM stack should start performing the operation specified by op_type . abort : signal that the host requested the current operation to abort, TPM stack may check this bit intermittently and either finish or stop executing the ongoing operation. complete : signal that the operation has been finished and TPM RAM contains the response (if any). Ports for TPM RAM interface: RAM_addr : address in RAM on which to operate, in bytes. RAM_data_r : data read from RAM_addr . RAM_data_w : data to be written at RAM_addr . RAM_wr : do a write. RAM_data_r is undefined as long as this signal is active, this is to allow for different FPGA implementations to be used. r512x32 This module is also part of TwPM_toplevel repository . It implements FPGA RAM (in this case BRAM is used) for TPM command and response buffer. As the name suggests, it has depth of 512 words, 32 bits each. The width was chosen to keep connection to WISHBONE simple. TPM registers module uses 8-bit accesses, with simple byte decoder implemented in top level module. While it would be possible to use dual-port RAM hardware macros, this implementation is more portable. Synthesis tools are usually smart enough to use those macros regardless. Implemented memory is simple read-first, one-port RAM with byte-enable signal for writes. Ports: A : address, counted in 32-bit words. WD , RD : input and output data, respectively. Clk : input clock, arbitrated by top level between LPC/SPI and system clocks. WEN : write enable for each byte of WD .","title":"Verilog modules"},{"location":"development/verilog_modules/#verilog-modules","text":"Below is description of FPGA modules used by TwPM for OrangeCrab. The design may change as the project progresses, state described here is valid for revision marked with tag v0.2.0 of the top module. This document includes diagrams generated with Symbolator . On these diagrams, input ports are on the left, and outputs and bi-directional signals are on the right. Module parameters are at the top, on gray background. In general, clocks are marked with triangle inside, and active-low signals with circle outside of rectangle symbolizing the module. However, Symbolator makes a guess about signal function based only on its name, which in some cases gives wrong results. Such cases are mentioned in the signal descriptions under the diagrams. Current FPGA utilization for LPC: Info: Device utilisation: Info: TRELLIS_IO: 65/ 197 32% Info: DCCA: 5/ 56 8% Info: DP16KD: 5/ 56 8% Info: MULT18X18D: 1/ 28 3% Info: ALU54B: 0/ 14 0% Info: EHXPLLL: 1/ 2 50% Info: EXTREFB: 0/ 1 0% Info: DCUA: 0/ 1 0% Info: PCSCLKDIV: 0/ 2 0% Info: IOLOGIC: 44/ 128 34% Info: SIOLOGIC: 0/ 69 0% Info: GSR: 0/ 1 0% Info: JTAGG: 0/ 1 0% Info: OSCG: 0/ 1 0% Info: SEDGA: 0/ 1 0% Info: DTR: 0/ 1 0% Info: USRMCLK: 1/ 1 100% Info: CLKDIVF: 1/ 4 25% Info: ECLKSYNCB: 1/ 10 10% Info: DLLDELD: 0/ 8 0% Info: DDRDLL: 1/ 4 25% Info: DQSBUFM: 2/ 8 25% Info: TRELLIS_ECLKBUF: 3/ 8 37% Info: ECLKBRIDGECS: 1/ 2 50% Info: DCSC: 0/ 2 0% Info: TRELLIS_FF: 5049/24288 20% Info: TRELLIS_COMB: 12639/24288 52% Info: TRELLIS_RAMW: 121/ 3036 3% Current FPGA utilization for SPI: Info: Device utilisation: Info: TRELLIS_IO: 62/ 197 31% Info: DCCA: 6/ 56 10% Info: DP16KD: 5/ 56 8% Info: MULT18X18D: 0/ 28 0% Info: ALU54B: 0/ 14 0% Info: EHXPLLL: 1/ 2 50% Info: EXTREFB: 0/ 1 0% Info: DCUA: 0/ 1 0% Info: PCSCLKDIV: 0/ 2 0% Info: IOLOGIC: 44/ 128 34% Info: SIOLOGIC: 0/ 69 0% Info: GSR: 0/ 1 0% Info: JTAGG: 0/ 1 0% Info: OSCG: 0/ 1 0% Info: SEDGA: 0/ 1 0% Info: DTR: 0/ 1 0% Info: USRMCLK: 1/ 1 100% Info: CLKDIVF: 1/ 4 25% Info: ECLKSYNCB: 1/ 10 10% Info: DLLDELD: 0/ 8 0% Info: DDRDLL: 1/ 4 25% Info: DQSBUFM: 2/ 8 25% Info: TRELLIS_ECLKBUF: 3/ 8 37% Info: ECLKBRIDGECS: 1/ 2 50% Info: DCSC: 0/ 2 0% Info: TRELLIS_FF: 5025/24288 20% Info: TRELLIS_COMB: 12175/24288 50% Info: TRELLIS_RAMW: 121/ 3036 3%","title":"Verilog modules"},{"location":"development/verilog_modules/#top-level","text":"Top level module code is located in this repository . It glues together other modules, which are referenced by that repository as git submodules. It also describes how the signals are connected to external IO pins. Top level module parameters: TPM_RAM_* , TPM_REGS_* , TPM_REG_* : those specify addresses and sizes used in Communication between SoC and FPGA . LITEDRAM_* and RAM_* : LiteDRAM controller and main (DDR3) RAM base address and size. DEFAULT_READ_VALUE : value read from TPM_REGS region outside of any defined register. COMPLETE_PULSE_WIDTH : width (in system clock cycles) of complete signal. See TPM registers module description for details on that signal. External ports: clk_i : input (crystal) clock running at 48 MHz. Note that it is only used for driving PLL, which in turn generates 50 MHz clock for most of the system. rstn_i : asynchronous reset signal, active low. It is converted to synchronous reset that is used for most of the components. (Note: it is not marked as negated on the diagram due to how Symbolator detects such signals, i.e. its name doesn't end with either _n or _b ). uart_rxd_i , uart_txd_o : UART running at 115200n8. LPC interface: those are to be connected to the mainboard, see Connecting TwPM to mainboard . Note that only one of LPC or SPI interface is present at any given time, depending on build configuration. SPI interface: those are to be connected to the mainboard, see Connecting TwPM to mainboard . Note that only one of LPC or SPI interface is present at any given time, depending on build configuration. SPI flash signals: connected to onboard SPI flash. Note that there is no clock signal on the diagram, a hardware macro must be used instead of defining it as a port. DDR3 interface: signals to and from onboard DRAM, connected directly to LiteDRAM module. Negative part of differential signals (CK, DQS) are implemented with hardware macros, so they are not listed as I/O ports. led_r , led_g , led_b : outputs driving RGB LED. All of them are active low (this is how LEDs usually work), even though only one of them is marked as such (again, due to how Symbolator parses names).","title":"Top level"},{"location":"development/verilog_modules/#neorv32","text":"The NEORV32 processor is used to run software TPM stack on. It is highly configurable, and many of its modules are disabled in TwPM, so not all of the Processor top entity signals are used. clk_i , rstn_i : main clock and reset signals. Note that these are not the top level clock and reset, instead these are outputs from LiteDRAM described below. This clock runs at 50 MHz. Reset is active-low, but Symbolator didn't represent it correctly on diagram. uart0_rxd_i , uart0_txd_o : main UART, connected directly to I/O pads. JTAG signals: unused for now. WISHBONE bus interface: configured as WISHBONE Classic. Used for accessing modules external to the processor, like TPM module, DRAM and LiteDRAM controller. SPI interface: connected to top level I/O either directly or through hardware macro ( spi_clk_o ). GPIO: only 3 outputs are connected to LEDs to provide some kind of output even if UART is not connected. Inputs are hardwired to 0 because there is no way of implementing just the outputs.","title":"NEORV32"},{"location":"development/verilog_modules/#litedram","text":"While the module was generated with LiteDRAM , the entire source is included in TwPM_toplevel repository , along with configuration file used to create it. This is done to make the code reproducible, as well as to add some customizations, listed in comment at the top of Verilog file. List of ports: clk , rst , user_clk and user_rst : this module implements PLL and reset synchronizer, these are respective inputs and outputs for them. On input we have 48 MHz clock and asynchronous reset, and on output 50 MHz clock with synchronous reset signal. Note that both reset signals are active-high , contrary to the rest of the project. Both are negated in top level module. DDR3 RAM signals: routed directly to top level module's ports. init_done , init_error , pll_locked : status signals, not really used in current implementation. First two are controlled by software doing the initialization, and the user_rst is active until PLL is locked, which in turn doesn't release NEORV32 core. pll_locked is connected to blue LED as a sign of life. RAM WISHBONE interface: WISHBONE Classic interface for accessing the main memory. Mostly standard, except for user_port_wishbone_adr - it specifies (4 bytes) word address, not byte address. Its width is also limited to the size of RAM. Controller WISHBONE interface: also a WISHBONE Classic interface, used to set up and initialize RAM before it is usable. Refer to the LiteDRAM and liblitedram (which for some reason is in main LiteX repository) for details on how to interact with it. wb_ctrl_adr is also using word addresses as above, but its width is not limited otherwise. Only lower bits are compared in the module, which means that top level has to arbitrate other signals (e.g. CYC or STB) to avoid aliasing.","title":"LiteDRAM"},{"location":"development/verilog_modules/#lpc-module","text":"Source code: Dasharo/verilog-lpc-module Testbench results: VCD info: dumpfile lpc_periph_tb.vcd opened for output. Performing TPM write w/o delay Performing TPM write with delay Performing TPM read with delay Performing TPM read w/o delay Testing reset behaviour - TPM write w/o delay Testing reset behaviour - TPM read w/o delay Testing reset behaviour - TPM write with delay Testing reset behaviour - TPM read with delay Testing non-TPM transactions Testing extended LFRAME# timings - write Testing extended LFRAME# timings - read Testing abort mechanism - write Testing abort mechanism - read Testing interrupts - Continuous mode: no interrupt reported when not requested? proper IRQ reported? IRQ number latched at start frame? IRQ keeps being sent while active? IRQ stops being sent when no longer active? recovery and turn-around phases executed when int is deactivated? IRQs reported with idle clock cycles before stop frame? IRQs reported with idle clock cycles after stop frame? IRQs reported with longer start pulse width? Testing interrupts - switching between modes: peripheral doesn't initialize SERIRQ cycle in Quiet mode when not needed? peripheral initializes SERIRQ cycle when IRQ needed in Quiet mode? reset switches peripheral to Continuous mode? Testing interrupts - Quiet mode: proper IRQ reported? IRQ number latched at start frame? IRQ keeps being sent while active? IRQ stops being sent when no longer active? recovery and turn-around phases executed when int is deactivated? IRQs reported with idle clock cycles before stop frame? peripheral keeps working after spurious interrupt? IRQs reported with longer start pulse width? Testing interrupts - IRQ stops being reported on reset lpc_periph_tb.v:1344: $stop called at 518601000 (1ps) This module is responsible for managing LPC communication. It responds only to TPM cycles, other cycle types are ignored. SERIRQ (both continuous and quiet mode), cycle aborts and LPC resets are implemented. Ports for LPC interface (refer to LPC specification for details): clk_i : LPC clock. nrst_i : LPC reset (active low). lframe_i : LPC frame input (active low). lad_bus : LPC data bus, slow pull-up on host side. serirq : LPC SERIRQ signal, slow pull-up on host side. More information about SERIRQ can be found here . Ports for signals to/from data provider: lpc_addr_o : 16-bit address of TPM register. lpc_data_i : data received from data provider (TPM registers module) to be sent to host. lpc_data_o : data received from host to be sent to TPM registers module. lpc_data_wr : signal to data provider that lpc_addr_o and lpc_data_o have valid data and write is requested. lpc_wr_done : signal from data provider that lpc_data_o has been read. This signal should be driven until LPC module stops driving lpc_data_wr , after which this signal should be stopped being driven no later than 1 clk_i cycle (30ns). LPC module changes lpc_data_wr on falling clk_i edge so it is suggested that data provider module samples that signal on rising edge. lpc_data_req : signal to data provider that data is requested (rising edge of this signal) or has been read (falling edge) from lpc_data_i . lpc_data_req is changed on falling edge of clk_i . lpc_data_rd : signal from data provider that lpc_data_i has valid data for reading. This signal should be driven in response to lpc_data_req . lpc_data_rd is sampled by LPC module on falling clk_i edge. This signal should be driven until LPC module stops driving lpc_data_req , after which this signal should be stopped being driven no later than 1 clk_i cycle (30ns). LPC module changes lpc_data_req on falling clk_i edge so it is suggested that data provider module samples that signal on rising edge. irq_num : IRQ (interrupt request) number, for TPM this is configured by TPM_INT_VECTOR_x.sirqVec (see TCG PC Client Platform TPM Profile Specification for TPM 2.0 chapter 6.6.1.3). No parsing is done by LPC module, meaning that both IRQ0 (which in some, but not all parts of TPM specification this means \"IRQ disabled\") and IRQ2 (SMI) are valid. IRQ number is sampled on clk_i falling edge on SERIRQ start frame, turn-around phase. This is done to avoid sending one interrupt with two different IRQ numbers in one cycle. interrupt : whether interrupt should be signaled to host to which TwPM is connected, active high. It is checked at the beginning of SERIRQ frame of IRQ latched from irq_num , both in quiet and continuous mode. In addition to that, in quiet mode this signal initializes SERIRQ cycle. Data provider should drive this signal as long as reason for interrupt is valid.","title":"LPC module"},{"location":"development/verilog_modules/#spi-module","text":"Source code: Dasharo/verilog-spi-module Testbench results: VCD info: dumpfile spi_periph_tb.vcd opened for output. Performing TPM write w/o delay Performing TPM write with delay Performing TPM read with delay Performing TPM read w/o delay Testing transfers with scattered clock between bytes Testing over-sized transfers Testing non-TPM addresses Testing crossing registers boundary spi_periph_tb.v:349: $stop called at 86540000 (1ps) This module is responsible for managing SPI communication with PC. It only supports SPI protocol as described in TPM specification. Ports for SPI interface: clk_i : SPI clock. cs_n : Chip select (active low). mosi : SPI Main Out Sub In. miso : SPI Main In Sub Out, slow pull-up on host side. Ports for signals to/from data provider: addr_o : 16-bit address of TPM register. data_i , data_o : data received from or sent to TPM registers module. data_wr : signal to data provider that addr_o and data_o have valid data and write is requested. wr_done : signal from data provider that data_o has been read. This signal isn't used by SPI module because it would most likely arrive when the clock is no longer running. Contrary to the LPC, SPI clock runs only during the transmission. data_req : signal to data provider that data is requested. data_rd : signal from data provider that data_i has valid data for reading. This signal should be driven in response to data_req . Note that there are no signals responsible for interrupts. SPI uses PIRQ, which doesn't require any additional logic, so interrupt signal from TPM registers module is used to drive it directly in the top level module.","title":"SPI module"},{"location":"development/verilog_modules/#tpm-registers-module","text":"Source code: Dasharo/verilog-tpm-fifo-registers Testbench results: VCD info: dumpfile regs_tb.vcd opened for output. Testing simple register reads without delay Testing simple register reads with delay Checking register values against expected.txt Checking if RO registers are writable Testing mechanisms for changing locality Testing mechanisms for seizing locality Testing TPM_INT_VECTOR write without delay - proper locality Testing TPM_INT_VECTOR write with delay - proper locality Testing TPM_INT_VECTOR write without delay - wrong locality Testing TPM_INT_VECTOR write with delay - wrong locality Testing TPM_INT_VECTOR write without delay - no locality Testing TPM_INT_VECTOR write with delay - no locality Testing command/response exchange and TPM state machine - basic Testing command/response exchange and TPM state machine - advanced regs_tb.v:1075: $stop called at 2023220000 (1ps) This module implements TPM register space. It also handles locality transitions, TPM interrupt generation and command finite state machine. Register values are reported accordingly to the current state. Registers not defined by PC Client specification return 0xFF on reads, and writes are dropped. The module is located between host interface module (LPC or SPI) and memory buffer for TPM commands and responses. It also exposes hardware interface that is translated by top module into software interface for TPM stack running on NEORV32 processor. Ports for signals to/from LPC or SPI module: clk_i : LPC/SPI clock is used for this module to allow for synchronous communication with LPC/SPI module. Because of that, all registers' values are available in one clock cycle and no wait states (LPC) or exactly one wait state (SPI) has to be inserted. For LPC,the clock is free-running, but for SPI it is enabled only during the communication. reset : reset signal, required to reset registers to their initial values, active low. addr_i : 16-bit address of register to access. data_i : 8-bit data from LPC/SPI module. data_o : 8-bit data to LPC/SPI module. data_wr , wr_done , data_req , data_rd : 4 signals coordinating communication over data_i and data_o . Their functions can be found in the LPC module description or SPI module description above. irq_num , interrupt : configuration and request of interrupts sent to host, see LPC module description for details. In case of SPI, interrupt is negated and routed directly to I/O pin in top level and irq_num is not used. Note that these are not interrupts sent towards NEORV32. Ports for signals for MCU interface: op_type : type of operation requested from TPM stack. Currently only 0 (no operation) and 1 (execute TPM2 command located in TPM RAM) are used. locality : locality at which the operation was requested. buf_len : length of data (e.g. TPM2 command) in TPM RAM. exec : signal that all of the above are valid and TPM stack should start performing the operation specified by op_type . abort : signal that the host requested the current operation to abort, TPM stack may check this bit intermittently and either finish or stop executing the ongoing operation. complete : signal that the operation has been finished and TPM RAM contains the response (if any). Ports for TPM RAM interface: RAM_addr : address in RAM on which to operate, in bytes. RAM_data_r : data read from RAM_addr . RAM_data_w : data to be written at RAM_addr . RAM_wr : do a write. RAM_data_r is undefined as long as this signal is active, this is to allow for different FPGA implementations to be used.","title":"TPM registers module"},{"location":"development/verilog_modules/#r512x32","text":"This module is also part of TwPM_toplevel repository . It implements FPGA RAM (in this case BRAM is used) for TPM command and response buffer. As the name suggests, it has depth of 512 words, 32 bits each. The width was chosen to keep connection to WISHBONE simple. TPM registers module uses 8-bit accesses, with simple byte decoder implemented in top level module. While it would be possible to use dual-port RAM hardware macros, this implementation is more portable. Synthesis tools are usually smart enough to use those macros regardless. Implemented memory is simple read-first, one-port RAM with byte-enable signal for writes. Ports: A : address, counted in 32-bit words. WD , RD : input and output data, respectively. Clk : input clock, arbitrated by top level between LPC/SPI and system clocks. WEN : write enable for each byte of WD .","title":"r512x32"},{"location":"explanation/","text":"Explanation Our explanatory and conceptual guides are written to provide a better understanding of how TwPM project works, and how it can be used. They also explain what are the motives behind some of the decisions, and what are the current goals and limitations of the project. Document Goal Hardware requirements Learn what kind of hardware requirements drive the hardware selection for the TwPM project Hardware selection Learn what kind of hardware was considered and selected for the PoC of the TwPM project Compliance Learn what is the current state of compliance with the TCG PC Client specification, and what are the known compliance limitations of the TwPM project","title":"Index"},{"location":"explanation/#explanation","text":"Our explanatory and conceptual guides are written to provide a better understanding of how TwPM project works, and how it can be used. They also explain what are the motives behind some of the decisions, and what are the current goals and limitations of the project. Document Goal Hardware requirements Learn what kind of hardware requirements drive the hardware selection for the TwPM project Hardware selection Learn what kind of hardware was considered and selected for the PoC of the TwPM project Compliance Learn what is the current state of compliance with the TCG PC Client specification, and what are the known compliance limitations of the TwPM project","title":"Explanation"},{"location":"explanation/compliance/","text":"Compliance with specification This page lists all recognized behaviors that differ from the specification. It also documents implementation details that TPM standards left as vendor- or implementation-specific. List of specifications TCG PC Client Platform TPM Profile Specification for TPM 2.0, Version 1.05, Revision 14, 9/4/2020 , shortened to PC Client PTP in this document Deviations from specifications None discovered at this point. Implementation details PC Client PTP, 6.5.2.4 Any write operation to the TPM_ACCESS_x register with more than one field set to a 1 MAY be treated as vendor specific. This implementation acts on least significant set bit. Reasoning behind such approach is that a write tries to request the use of locality peacefully before seizing it, if both corresponding bits in TPM_ACCESS_x register are set.","title":"Compliance"},{"location":"explanation/compliance/#compliance-with-specification","text":"This page lists all recognized behaviors that differ from the specification. It also documents implementation details that TPM standards left as vendor- or implementation-specific.","title":"Compliance with specification"},{"location":"explanation/compliance/#list-of-specifications","text":"TCG PC Client Platform TPM Profile Specification for TPM 2.0, Version 1.05, Revision 14, 9/4/2020 , shortened to PC Client PTP in this document","title":"List of specifications"},{"location":"explanation/compliance/#deviations-from-specifications","text":"None discovered at this point.","title":"Deviations from specifications"},{"location":"explanation/compliance/#implementation-details","text":"","title":"Implementation details"},{"location":"explanation/hardware-requirements/","text":"Hardware requirements for the TwPM module Intro The goal of this document is to list the most important requirements, which must be met by the TwPM module to maintain the minimum level of compatibility with the TCG PC Client Platform TPM Profile Specification for TPM 2.0 , and the available mainboards. These requirements will guide us during the hardware selection process, so we can select a development board, that will allow us to implement the minimum viable PoC (and later, hopefully, the complete solution as well). Power supply Voltage TPM MUST support a supply voltage of 1.8V or 3.3V. TPM MAY support supply and I/O voltages of both 1.8V and 3.3V. TPM MAY support other supply voltages. Source: [TCG PC Client Specific TPM Interface Specification], section 6.4.2 Electrical Specification . Maximum current Maximum power supply taken by TPM MUST be 250mA. Source: TCG PC Client Platform TPM Profile Specification for TPM 2.0 , Table 60 . Memory NV memory requirements from TPM specification The TPM SHALL be capable of supporting a minimum of 100KB written to TPM non-volatile memory over the life of the TPM. The TPM shall support allocation of at least 68 indices, with a total minimum data size of 3834 Bytes (decimal). The TPM specification does not define the required lifetime or endurance of the NV memory. Additional memory requirements, for program and data: At least 2 blocks, 16KiB each for NV data (plus application) At least 1 block, 16KiB RAM (plus RAM used by the application) Source: TCG PC Client Platform TPM Profile Specification for TPM 2.0 , section 4.5.1 NV Storage Requirements . Firmware stack requirements Based on the experiments with the ms-tpm-20-ref up to date, we estimate the reasonable minimal requirements to be: 1 MB of flash, 128 KB of RAM. During the early stages of the project, we prefer to focus on features, not fighting with memory optimization. SPI interface The TwPM is going to be an SPI slave device and must comply with the SPI clock frequency offered by the SPI host on the mainboard. We can look at the required SPI frequency from two angles: what TPM specification requires in this area, what SPI host frequencies are offered by the existing mainboards (chipsets). Frequency (TPM specification) TPM must be capable of operating at frequencies 10-24 MHz. However, the maximum frequency requirement may be raised in the future, so the target platform should have the SPI interface with the capability to handle higher frequencies. Source: TCG PC Client Platform TPM Profile Specification for TPM 2.0 , section 6.4.1 Clocking . Frequency (mainboards/chipsets) The PCH\u2019s SPI0 flash controller supports a discrete TPM on the platform via its dedicated SPI0_CS2# signal. The platform must have no more than 1 TPM. SPI0 controller supports accesses to the SPI0 TPM at approximately 17 MHz , 33 MHz , and 48 MHz depending on the PCH soft strap. 20 MHz is the reset default, and a valid PCH soft strap setting can override that. Based on the above, the device must support an SPI clock of at least 20MHz (preferably more - 33 MHz , and 48 MHz ). Source: Intel\u00ae 300 Series Chipset Family On-Package Platform Controller Hub (PCH) Datasheet, Volume 1 of 2 Intel\u00ae 600 Series Chipset Family Platform Controller Hub Datasheet, Volume 1 of 2 LPC interface Interrupts Service of SIRQ protocol for interrupts Implementation: emulate the set of individual hardware signals using time division multiplexing between frames Source: TCG PC Client Platform TPM Profile Specification for TPM 2.0 , section 6.6.1 LPC Interrupts . Timings Command Duration Duration and Timeouts for some commands are specified in Table 17 - Command Timing Some examples of timing/duration [ms]: TPM2_Startup : 20/750 TPM2_GetRandom : 750/2000 TPM2_PCR_Extend : 20/750 Source: TCG PC Client Platform TPM Profile Specification for TPM 2.0 , section 6.5.1.3 Command Duration . Timeouts Default values timeouts: TIMEOUT_A - default value 750ms TIMEOUT_B - default value 2s TIMEOUT_C - default value 750ms TIMEOUT_D - default value 750ms Source: TCG PC Client Platform TPM Profile Specification for TPM 2.0 , section 6.5.1.4 Interface Timeouts . Reset timings Within 500 microseconds of the completion of TPM_Init : all fields within all TPM_ACCESS_x registers must be valid logical level as indicated by the tpmRegValidSts field; Within 30 milliseconds of the completion of TPM_Init : all fields within the access register and all other registers must return with the state of their fields valid the TPM must be ready to receive a command Source: TCG PC Client Platform TPM Profile Specification for TPM 2.0 , section 7.6 Reset Timing . References TCG PC Client Platform TPM Profile Specification for TPM 2.0 , Version: 1.05 Revision: 14 Date: September 4, 2020 Summary Power supply requirements are quite important: the voltage one can be fulfilled by adding another converter on the board, if necessary, the current consumption will be very important in the final product (so the module can work powered from the mainboard), but in the PoC phase, we may work around that. The timings may be important later on for some performance testing, but it is very difficult to judge at this stage of the project, whether the given hardware can achieve such metrics. We will not use them as input for the initial hardware selection. Requirements on flash and RAM are mostly driven by the firmware stack requirements, as the requirements from the TPM specification are negligible in comparison to that. The most important requirements are SPI and LPC interfaces, as without these, the module would not be able to communicate with the mainboard properly, so even a functional PoC cannot be constructed.","title":"Hardware requirements"},{"location":"explanation/hardware-requirements/#hardware-requirements-for-the-twpm-module","text":"","title":"Hardware requirements for the TwPM module"},{"location":"explanation/hardware-requirements/#intro","text":"The goal of this document is to list the most important requirements, which must be met by the TwPM module to maintain the minimum level of compatibility with the TCG PC Client Platform TPM Profile Specification for TPM 2.0 , and the available mainboards. These requirements will guide us during the hardware selection process, so we can select a development board, that will allow us to implement the minimum viable PoC (and later, hopefully, the complete solution as well).","title":"Intro"},{"location":"explanation/hardware-requirements/#power-supply","text":"","title":"Power supply"},{"location":"explanation/hardware-requirements/#memory","text":"","title":"Memory"},{"location":"explanation/hardware-requirements/#spi-interface","text":"The TwPM is going to be an SPI slave device and must comply with the SPI clock frequency offered by the SPI host on the mainboard. We can look at the required SPI frequency from two angles: what TPM specification requires in this area, what SPI host frequencies are offered by the existing mainboards (chipsets).","title":"SPI interface"},{"location":"explanation/hardware-requirements/#lpc-interface","text":"","title":"LPC interface"},{"location":"explanation/hardware-requirements/#timings","text":"","title":"Timings"},{"location":"explanation/hardware-requirements/#references","text":"TCG PC Client Platform TPM Profile Specification for TPM 2.0 , Version: 1.05 Revision: 14 Date: September 4, 2020","title":"References"},{"location":"explanation/hardware-requirements/#summary","text":"Power supply requirements are quite important: the voltage one can be fulfilled by adding another converter on the board, if necessary, the current consumption will be very important in the final product (so the module can work powered from the mainboard), but in the PoC phase, we may work around that. The timings may be important later on for some performance testing, but it is very difficult to judge at this stage of the project, whether the given hardware can achieve such metrics. We will not use them as input for the initial hardware selection. Requirements on flash and RAM are mostly driven by the firmware stack requirements, as the requirements from the TPM specification are negligible in comparison to that. The most important requirements are SPI and LPC interfaces, as without these, the module would not be able to communicate with the mainboard properly, so even a functional PoC cannot be constructed.","title":"Summary"},{"location":"explanation/hardware-selection/","text":"Hardware selection Update - October 2023 TPM registers generally can't be implemented on MCU side because most of them have to return valid values without using LPC wait cycles. This means that there are only 3 LPC clock cycles between last nibble of address and first nibble of response, which gives 3.5 periods (because data must start being driven on complementary edge with regard to sampling) for MCU to be notified about the read, read and parse the address, check current state and finally create and send the response. By transforming from LPC frequency (33 MHz) to M4 frequency (80 MHz) this gives about 8 CPU cycles, depending on relative position of clock edges. MCU can't keep checking for requests in a busy loop because it is perfectly valid for host (PC) to read status register in order to check whether command executed by TPM already finished or not. For this reason interrupts must be used, which adds delay of 12 cycles (in good conditions, may be more). Additional delay may be applied because multiple bridges and clock domains exist between FPGA and M4 core. M4 has 3-stage pipeline, which steals another 3 cycles. Then result has to be sent back to FPGA through bridges mentioned earlier. Even without those, delay is already twice bigger than allowed, and it doesn't include any code to actually parse the request. For this reason, TPM register space must be implemented on FPGA side. Unfortunately, FPGA available on EOS S3 platform isn't fast enough to implement TPM register space logic and LPC running with standard frequency (33 MHz). Raw LPC module allowed for ~30 MHz without any optimisations, but it is possible that part of implementation was optimised out as unused - Yosys doesn't clearly report such cases. With TPM registers module and rather heavy optimising we could get to ~16.5 MHz, but this is way below the requirements. We decided to switch to OrangeCrab with Lattice LFE5U-25F-8MG285C FPGA. It has the Feather format, about 23 x 51 mm (slightly shorter than EOS S3), and has enough I/O for interfaces we need. Intro The goal of this document is to select a target hardware (development board), which will be used for the development and prototyping of the TwPM. We have pre-selected some of the boards based on our best knowledge, and some suggestions from the community (e.g. during and after our presentation at FOSDEM 2023 ). We aim to evaluate whether the pre-selected boards can meet the identified hardware requirements . Infineon CY8C6xxxx Series Basic information SoC SoC integrates 2 CPUs as part of its structure: ARM Cortex M4 (150MHz) ARM Cortex M0+ (100MHz) Memory: Flash: 384-1856 KB RAM: 176-944KB Interfaces I2C, SPI, UART, USB Voltage range: 1.71 to 5.5V SPI slave frequency 25 MHz Cryptographic accelerators DES/TDES, AES, SHA, CRC, TRNG, RSA/ECC Tools and documentation Modus Toolbox SoC datasheet SparkFun QuickLogic Thing Plus - EOS S3 SoC eFPGA-enabled ARM Cortex\u00a9-M4F MCU Memory Flash: 2 MB NOR RAM: up to 512 KB Interfaces: FPGA-based solution Voltage range: 1.7 to 3.6V SPI slave frequency Up to 20 MHz in slave mode Cryptographic accelerators Can be implemented in FPGA Tools and documentation Supports open-source FPGA synthesis software - SymbiFlow (now known as F4PGA). Partial upstream support from F4PGA lack of BlockRAM support can be a serious obstacle for complex FPGA designs, but should not be a problem for a simple LPC controller Downstream support for Zephyr and FreeRTOS (as part of the QORC SDK ) Based on an old version of Zephyr Mainline Zephyr supports the most basic peripherals, and may be generally not usable without porting additional drivers Board webpage SoC datasheet STM32L476RG Nucleo board CPU ARM Cortex-M4 MCU with FPU (80MHz) with low power Memory Flash: 1 MB RAM: 128 KB Interfaces I2C, SPI, UART, USB Voltage range: 1.71 to 5.5V SPI slave frequency In reality, the maximum SPI slave frequency achieved on this board so far was 24 MHz and it worked reliably when writing only, not while reading. More details can be found in this blogpost . SPI clock frequency: Slave mode receiver, 1.7 < VDD < 3.6V: 40MHz Full duplex/Slave mode transmit, 2.7 < VDD < 3.6V: 26MHz Full duplex/Slave mode transmit, 1.71 < VDD < 3.6V: 16MHz Cryptographic accelerators True RNG Some (but not the one installed on the Nucleo board by default) STM32 chips from this family offer also AES-128, AES-256 hardware encryption Tools and documentation Good open-source RTOS Support (e.g. Zephyr ) STM32CubeIDE STM32L476RG Nucleo Web Page STM32L476RG Nucleo Datasheet STM32G474RE Nucleo board CPU ARM Cortex-M4 MCU (170MHz) Memory: Flash: 512 KB RAM: 128 KB (32 KB is used for parity checks, so only 96 KB is available for program usage) Interfaces I2C, SPI, UART, USB Voltage range: 1.71 to 5.5V SPI slave frequency Max SPI clock frequency: Slave, receiver mode, 1.71V < Vdd < 3.6V: 50MHz Slave mode transmitter, with full duplex, 2.7V < Vdd < 3.6V: 41MHz Slave mode Transmitter, with full duplex, 1.7V < Vdd < 3.6V: 27MHz Cryptographic accelerators True RNG Some (but not the one installed on the Nucleo board by default) STM32 chips from this family offer also AES-128, AES-256 hardware encryption Mathematical hardware accelerators CORDIC for trigonometric functions acceleration FMAC: filter mathematical accelerator these are not that useful for the TwPM use-case Tools and documentation Good open-source RTOS Support (e.g. Zephyr ) STM32CubeIDE STM32G474 Nucleo Web Page STM32L476RG Nucleo Datasheet Scoring methodology Following methodology is applied to assign grades in the below table: if the desired value is met, then +1 , if the desired value is not met, then 0 , if the desired value is not present and would be difficult to workaround (or there is no data about the given property), then -1 , if this is a critical requirement, then multiply the result by 2 (critical requirements are marked in bold in the table below). Summary The above report outlines 4 development boards, that were evaluated more closely, after the initial research. The supply voltage was not a challenging requirement and is similar across devices. The actual data on current consumption is not clear at the moment. It might also highly depend on the workflow, and enabled peripherals. To indicate that risk, -1 grade was added, where applicable. It will need actual measurements in the future. All of the boards should meet the RAM and CPU requirements (although that was was set to an arbitrary value right now, and is subject to change in the future). The most flexible choice would be the board with the EOS S3 SoC, due to the significant RAM and flash size, and integrated FPGA, which allows us to implement LPC interface, and potentially also offload other features (SPI, crypto), as needed If we would want to implement a TwPM module with SPI interface only, we could try to go with either STM32L476RG , or STM32G474RE . The first one has a bit more resources (flash, and RAM), but the second one features much higher CPU and SPI speeds, which makes it an interesting target for the future. Property Desired value CY8C6xxxx EOS S3 STM32L476RG STM32G474RE Supply voltage 1.8-3.3 V (+1) 1.7-5.5 V (+1) 1.62-3.63 V (+1) 1.71-3.6 V (+1) 1.71-3.6 (+1) Current < 250 mA (no data) (-1) (no data) (-1) (no data) (-1) (no data) (-1) Flash >= 1 MB 384-1856 KB (+1) 2 MB (+1) 1 MB (+1) 512 KB (0) RAM >= 128 KB 176-944KB (+2) 512 KB (+2) 128 KB (+2) 128 KB 8 (0) Clock Frequency >= 80 MHz 150 MHz (+1) 80 MHz (+1) 80 (+1) 170 (+1) LPC interface yes no 5 (0) no 6 (0) no (-2) no (-2) SPI Frequency >= 20 MHz 25 MHz (+2) 20 (+2) 26 (+1) 41 (+2) OSS support Fully OSS toolchain limited (-2) 1 yes, limited (+1) 3 yes (+2) yes (+2) Crypto Acceleration RNG/hash/enc AES/SHA/RNG (+1) 2 can use FPGA (+1) 4 RNG (+1) 7 RNG (+1) 7 Score 5 8 6 4 It looks like the usage of proprietary tools is required, especially for the programmable logic part \u21a9 Score is increased from +1 o +2 due to the support of additional hash/encryption algorithms \u21a9 Support in the upstream project might miss some crucial drivers, as described in the EOS S3 section \u21a9 The SoC does not provide crypto accelerators, but we could potentially use FPGA to offload some operations \u21a9 Potentially could be implemented in programmable logic (not a \"standard\" FPGA) \u21a9 Can be implemented in FPGA via LPC module, for example via Verilog \u21a9 Some STM32 chips from this family offer also AES-128, AES-256 hardware encryption \u21a9 \u21a9 32 KB is used for parity checks, so only 96 KB is available for program usage \u21a9","title":"Hardware selection"},{"location":"explanation/hardware-selection/#hardware-selection","text":"","title":"Hardware selection"},{"location":"explanation/hardware-selection/#update-october-2023","text":"TPM registers generally can't be implemented on MCU side because most of them have to return valid values without using LPC wait cycles. This means that there are only 3 LPC clock cycles between last nibble of address and first nibble of response, which gives 3.5 periods (because data must start being driven on complementary edge with regard to sampling) for MCU to be notified about the read, read and parse the address, check current state and finally create and send the response. By transforming from LPC frequency (33 MHz) to M4 frequency (80 MHz) this gives about 8 CPU cycles, depending on relative position of clock edges. MCU can't keep checking for requests in a busy loop because it is perfectly valid for host (PC) to read status register in order to check whether command executed by TPM already finished or not. For this reason interrupts must be used, which adds delay of 12 cycles (in good conditions, may be more). Additional delay may be applied because multiple bridges and clock domains exist between FPGA and M4 core. M4 has 3-stage pipeline, which steals another 3 cycles. Then result has to be sent back to FPGA through bridges mentioned earlier. Even without those, delay is already twice bigger than allowed, and it doesn't include any code to actually parse the request. For this reason, TPM register space must be implemented on FPGA side. Unfortunately, FPGA available on EOS S3 platform isn't fast enough to implement TPM register space logic and LPC running with standard frequency (33 MHz). Raw LPC module allowed for ~30 MHz without any optimisations, but it is possible that part of implementation was optimised out as unused - Yosys doesn't clearly report such cases. With TPM registers module and rather heavy optimising we could get to ~16.5 MHz, but this is way below the requirements. We decided to switch to OrangeCrab with Lattice LFE5U-25F-8MG285C FPGA. It has the Feather format, about 23 x 51 mm (slightly shorter than EOS S3), and has enough I/O for interfaces we need.","title":"Update - October 2023"},{"location":"explanation/hardware-selection/#intro","text":"The goal of this document is to select a target hardware (development board), which will be used for the development and prototyping of the TwPM. We have pre-selected some of the boards based on our best knowledge, and some suggestions from the community (e.g. during and after our presentation at FOSDEM 2023 ). We aim to evaluate whether the pre-selected boards can meet the identified hardware requirements .","title":"Intro"},{"location":"explanation/hardware-selection/#infineon-cy8c6xxxx-series","text":"","title":"Infineon CY8C6xxxx Series"},{"location":"explanation/hardware-selection/#sparkfun-quicklogic-thing-plus-eos-s3","text":"SoC eFPGA-enabled ARM Cortex\u00a9-M4F MCU Memory Flash: 2 MB NOR RAM: up to 512 KB Interfaces: FPGA-based solution Voltage range: 1.7 to 3.6V","title":"SparkFun QuickLogic Thing Plus - EOS S3"},{"location":"explanation/hardware-selection/#stm32l476rg-nucleo-board","text":"CPU ARM Cortex-M4 MCU with FPU (80MHz) with low power Memory Flash: 1 MB RAM: 128 KB Interfaces I2C, SPI, UART, USB Voltage range: 1.71 to 5.5V","title":"STM32L476RG Nucleo board"},{"location":"explanation/hardware-selection/#stm32g474re-nucleo-board","text":"CPU ARM Cortex-M4 MCU (170MHz) Memory: Flash: 512 KB RAM: 128 KB (32 KB is used for parity checks, so only 96 KB is available for program usage) Interfaces I2C, SPI, UART, USB Voltage range: 1.71 to 5.5V","title":"STM32G474RE Nucleo board"},{"location":"explanation/hardware-selection/#scoring-methodology","text":"Following methodology is applied to assign grades in the below table: if the desired value is met, then +1 , if the desired value is not met, then 0 , if the desired value is not present and would be difficult to workaround (or there is no data about the given property), then -1 , if this is a critical requirement, then multiply the result by 2 (critical requirements are marked in bold in the table below).","title":"Scoring methodology"},{"location":"explanation/hardware-selection/#summary","text":"The above report outlines 4 development boards, that were evaluated more closely, after the initial research. The supply voltage was not a challenging requirement and is similar across devices. The actual data on current consumption is not clear at the moment. It might also highly depend on the workflow, and enabled peripherals. To indicate that risk, -1 grade was added, where applicable. It will need actual measurements in the future. All of the boards should meet the RAM and CPU requirements (although that was was set to an arbitrary value right now, and is subject to change in the future). The most flexible choice would be the board with the EOS S3 SoC, due to the significant RAM and flash size, and integrated FPGA, which allows us to implement LPC interface, and potentially also offload other features (SPI, crypto), as needed If we would want to implement a TwPM module with SPI interface only, we could try to go with either STM32L476RG , or STM32G474RE . The first one has a bit more resources (flash, and RAM), but the second one features much higher CPU and SPI speeds, which makes it an interesting target for the future. Property Desired value CY8C6xxxx EOS S3 STM32L476RG STM32G474RE Supply voltage 1.8-3.3 V (+1) 1.7-5.5 V (+1) 1.62-3.63 V (+1) 1.71-3.6 V (+1) 1.71-3.6 (+1) Current < 250 mA (no data) (-1) (no data) (-1) (no data) (-1) (no data) (-1) Flash >= 1 MB 384-1856 KB (+1) 2 MB (+1) 1 MB (+1) 512 KB (0) RAM >= 128 KB 176-944KB (+2) 512 KB (+2) 128 KB (+2) 128 KB 8 (0) Clock Frequency >= 80 MHz 150 MHz (+1) 80 MHz (+1) 80 (+1) 170 (+1) LPC interface yes no 5 (0) no 6 (0) no (-2) no (-2) SPI Frequency >= 20 MHz 25 MHz (+2) 20 (+2) 26 (+1) 41 (+2) OSS support Fully OSS toolchain limited (-2) 1 yes, limited (+1) 3 yes (+2) yes (+2) Crypto Acceleration RNG/hash/enc AES/SHA/RNG (+1) 2 can use FPGA (+1) 4 RNG (+1) 7 RNG (+1) 7 Score 5 8 6 4 It looks like the usage of proprietary tools is required, especially for the programmable logic part \u21a9 Score is increased from +1 o +2 due to the support of additional hash/encryption algorithms \u21a9 Support in the upstream project might miss some crucial drivers, as described in the EOS S3 section \u21a9 The SoC does not provide crypto accelerators, but we could potentially use FPGA to offload some operations \u21a9 Potentially could be implemented in programmable logic (not a \"standard\" FPGA) \u21a9 Can be implemented in FPGA via LPC module, for example via Verilog \u21a9 Some STM32 chips from this family offer also AES-128, AES-256 hardware encryption \u21a9 \u21a9 32 KB is used for parity checks, so only 96 KB is available for program usage \u21a9","title":"Summary"},{"location":"roadmap/","text":"Roadmap TwPM project is funded by the NLnet Foundation via the NGI ASSURE . 3mdeb has proposed to implement the following tasks under the grant agreement No 957073. 1. Public site with documentation All of the documentation produced during this project should be publicly available to users and developers. Milestones: create repositories for the project prepare server and domain name describe project's purpose and phases create placeholders for description of deviations from TPM specification, software stack and documentation changelog that will be updated after each of the remaining phases State: Done (this website) 2. Gather hardware requirements and choose target board TPMs are connected to the mainboard of PC. They have maximum allowed power consumption and boot time. Based on those requirements and additional factors like cost, availability and ease of use with open source tools we have to choose a board for reference implementation. Milestones: documentation of hardware requirements analysis and comparison of available boards establishment of reference board review and update existing documentation, add entry to changelog State: Done 3. Implement LPC protocol in FPGA While the newest computers use SPI for connecting TPM devices to the mainboard, slightly older, but still widely used hardware uses Low Pin Count (LPC) interface. Implementing this protocol at software level through bit-banging would require very high speed micro-controllers, which would make the cost and power consumption unreasonably high. To the best of our knowledge, there are no MCUs that have LPC controller included as a hardware part of SoC, due to the fact that LPC is specific to PC only. For these reasons hardware implementation is required. Milestones: design and implementation of LPC peripheral in Verilog simulation of synthesized code documentation describing connection between designed TPM and mainboard review and update existing documentation, add entry to changelog State: Done 4. Implement basic TPM registers in FPGA Most of the hardware TPM registers must return result immediately or almost immediately. MCUs and their communication with FPGA are not fast enough to acknowledge, parse, prepare response and send it to host in time. Hardware implementation is required for registers that require fast response. Milestones: implementation of TPM register space implementation of finite state machine for changing localities review and update existing documentation, add entry to changelog State: Done 5. Implement TPM command parsing and communication between FPGA and MCU Minimal parsing of commands and responses (limited to just their sizes) must be done on FPGA side in order to properly set status bits that host can use to check whether TPM expects more bytes of command or has more bytes of response. Full command parsing and execution takes place on MCU, so FPGA has to implement and expose buffer with command sent by host, along with any required metadata like type of message in the buffer or currently active locality. Milestones: implementation of FIFO on FPGA implementation of command machine state design, implementation and documentation of protocol of communication between FPGA and MCU application code for reading data from FIFO, passing parsed commands to the TPM stack and writing responses back to FIFO review and update existing documentation, add entry to changelog State: Done 6. Base tests For testing of the implementation done so far, a subset of tpm2-tools commands will be used. Only commands that do not depend on Protected Storage, RNG and Primary Keys Certificates will be tested at this point. Milestone: test suite: PCR operations (read, extend, reset values, locality protection) test suite: object creation (primary, ordinary, derived objects of various types) test suite: cryptographic support functions (hash, HMAC, encryption, signing) documentation of results review and update existing documentation, add entry to changelog State: Done 7. Implement SPI TPM protocol SPI implementation on MCU may not be feasible because some of the registers must return proper values immediately. This task consists of repeating all the tasks that were done on FPGA side for LPC, but this time SPI is used as physical interface. Milestones: design and implementation of LPC peripheral in Verilog simulation of synthesized code documentation describing connection between designed TPM and mainboard implementation of TPM register space review and update existing documentation, add entry to changelog State: Done 8. Explore the usage of using simpler hardware platform Additionally, we want to explore whether we can meet the TPM specification requirements using simpler (and cheaper) microcontroller platform (with no FPGA involved). That may not be feasible due to the hardware limitations, but it is a great potential opportunity of increasing the adoption of the solution, so that is why believe it makes sense to try to purse that and publish the results. Milestones: explore usage of the solution using simpler hardware platform (with no FPGA) publish test results to the public documentation website review and update existing documentation, add entry to changelog State: Done 9. Flash driver for TPM stack Nonvolatile storage is an integral part of TPM. It allows for saving user- or vendor-defined data inside TPM, potentially with protection based on state of TPM (PCR values, authorization sessions). With NVRAM implemented, additional tests can be performed. Milestones: flash driver for chosen board (if not available yet or has limited support) integration of the TPM stack with flash driver test suite: NV memory (persistent objects and data, vendor certificates) test suite: attestation and authorization (quote, authorization sessions) test suite: use in real-world scenario (Fobnail) review and update existing documentation, add entry to changelog State: In progress 10. Unique identification and randomness source Each TPM has to be uniquely identifiable. This uniqueness is used e.g. to create primary seeds which are used to derive primary keys for various hierarchies. Random number generator is also included in this task - unique registers (with e.g. serial numbers) and RNG engines are usually specific to the given hardware. FPGA can also be used if any of those isn't available or doesn't have enough entropy on MCU. Milestones: find and obtain enough bits of unique data identifying the platform find and obtain enough bits of entropy for seeding PRNG test suite: Windows HLK review and update existing documentation, add entry to changelog State: In progress 11. Manufacturing process Each TPM must be individually manufactured. This consists of committing vendor certificate for TPM's primary Endorsement Key (EK) to its nonvolatile memory. As each EK is unique, so is its certificate, and it must be sign by key which chain of trust is rooted in publicly available vendor's root certificate. Milestones: create manufacturing process post the process on the documentation site create script for automation of manufacturing process review and update existing documentation, add entry to changelog State: Backlog 12. Customizable configuration Platforms other than the reference one may support different functionalities, or may have limited performance. To make transition to different hardware easier, some options should be made configurable. This may include available hash algorithms in TPM stack, physical interface used (LPC or SPI), presence of hardware RNG engine, amount of nonvolatile memory. Milestones: create easy to use build system integrating whole stack prepare configuration file for whole project review and update existing documentation, add entry to changelog State: In progress","title":"Index"},{"location":"roadmap/#roadmap","text":"TwPM project is funded by the NLnet Foundation via the NGI ASSURE . 3mdeb has proposed to implement the following tasks under the grant agreement No 957073.","title":"Roadmap"},{"location":"roadmap/#1-public-site-with-documentation","text":"All of the documentation produced during this project should be publicly available to users and developers. Milestones: create repositories for the project prepare server and domain name describe project's purpose and phases create placeholders for description of deviations from TPM specification, software stack and documentation changelog that will be updated after each of the remaining phases State: Done (this website)","title":"1. Public site with documentation"},{"location":"roadmap/#2-gather-hardware-requirements-and-choose-target-board","text":"TPMs are connected to the mainboard of PC. They have maximum allowed power consumption and boot time. Based on those requirements and additional factors like cost, availability and ease of use with open source tools we have to choose a board for reference implementation. Milestones: documentation of hardware requirements analysis and comparison of available boards establishment of reference board review and update existing documentation, add entry to changelog State: Done","title":"2. Gather hardware requirements and choose target board"},{"location":"roadmap/#3-implement-lpc-protocol-in-fpga","text":"While the newest computers use SPI for connecting TPM devices to the mainboard, slightly older, but still widely used hardware uses Low Pin Count (LPC) interface. Implementing this protocol at software level through bit-banging would require very high speed micro-controllers, which would make the cost and power consumption unreasonably high. To the best of our knowledge, there are no MCUs that have LPC controller included as a hardware part of SoC, due to the fact that LPC is specific to PC only. For these reasons hardware implementation is required. Milestones: design and implementation of LPC peripheral in Verilog simulation of synthesized code documentation describing connection between designed TPM and mainboard review and update existing documentation, add entry to changelog State: Done","title":"3. Implement LPC protocol in FPGA"},{"location":"roadmap/#4-implement-basic-tpm-registers-in-fpga","text":"Most of the hardware TPM registers must return result immediately or almost immediately. MCUs and their communication with FPGA are not fast enough to acknowledge, parse, prepare response and send it to host in time. Hardware implementation is required for registers that require fast response. Milestones: implementation of TPM register space implementation of finite state machine for changing localities review and update existing documentation, add entry to changelog State: Done","title":"4. Implement basic TPM registers in FPGA"},{"location":"roadmap/#5-implement-tpm-command-parsing-and-communication-between-fpga-and-mcu","text":"Minimal parsing of commands and responses (limited to just their sizes) must be done on FPGA side in order to properly set status bits that host can use to check whether TPM expects more bytes of command or has more bytes of response. Full command parsing and execution takes place on MCU, so FPGA has to implement and expose buffer with command sent by host, along with any required metadata like type of message in the buffer or currently active locality. Milestones: implementation of FIFO on FPGA implementation of command machine state design, implementation and documentation of protocol of communication between FPGA and MCU application code for reading data from FIFO, passing parsed commands to the TPM stack and writing responses back to FIFO review and update existing documentation, add entry to changelog State: Done","title":"5. Implement TPM command parsing and communication between FPGA and MCU"},{"location":"roadmap/#6-base-tests","text":"For testing of the implementation done so far, a subset of tpm2-tools commands will be used. Only commands that do not depend on Protected Storage, RNG and Primary Keys Certificates will be tested at this point. Milestone: test suite: PCR operations (read, extend, reset values, locality protection) test suite: object creation (primary, ordinary, derived objects of various types) test suite: cryptographic support functions (hash, HMAC, encryption, signing) documentation of results review and update existing documentation, add entry to changelog State: Done","title":"6. Base tests"},{"location":"roadmap/#7-implement-spi-tpm-protocol","text":"SPI implementation on MCU may not be feasible because some of the registers must return proper values immediately. This task consists of repeating all the tasks that were done on FPGA side for LPC, but this time SPI is used as physical interface. Milestones: design and implementation of LPC peripheral in Verilog simulation of synthesized code documentation describing connection between designed TPM and mainboard implementation of TPM register space review and update existing documentation, add entry to changelog State: Done","title":"7. Implement SPI TPM protocol"},{"location":"roadmap/#8-explore-the-usage-of-using-simpler-hardware-platform","text":"Additionally, we want to explore whether we can meet the TPM specification requirements using simpler (and cheaper) microcontroller platform (with no FPGA involved). That may not be feasible due to the hardware limitations, but it is a great potential opportunity of increasing the adoption of the solution, so that is why believe it makes sense to try to purse that and publish the results. Milestones: explore usage of the solution using simpler hardware platform (with no FPGA) publish test results to the public documentation website review and update existing documentation, add entry to changelog State: Done","title":"8. Explore the usage of using simpler hardware platform"},{"location":"roadmap/#9-flash-driver-for-tpm-stack","text":"Nonvolatile storage is an integral part of TPM. It allows for saving user- or vendor-defined data inside TPM, potentially with protection based on state of TPM (PCR values, authorization sessions). With NVRAM implemented, additional tests can be performed. Milestones: flash driver for chosen board (if not available yet or has limited support) integration of the TPM stack with flash driver test suite: NV memory (persistent objects and data, vendor certificates) test suite: attestation and authorization (quote, authorization sessions) test suite: use in real-world scenario (Fobnail) review and update existing documentation, add entry to changelog State: In progress","title":"9. Flash driver for TPM stack"},{"location":"roadmap/#10-unique-identification-and-randomness-source","text":"Each TPM has to be uniquely identifiable. This uniqueness is used e.g. to create primary seeds which are used to derive primary keys for various hierarchies. Random number generator is also included in this task - unique registers (with e.g. serial numbers) and RNG engines are usually specific to the given hardware. FPGA can also be used if any of those isn't available or doesn't have enough entropy on MCU. Milestones: find and obtain enough bits of unique data identifying the platform find and obtain enough bits of entropy for seeding PRNG test suite: Windows HLK review and update existing documentation, add entry to changelog State: In progress","title":"10. Unique identification and randomness source"},{"location":"roadmap/#11-manufacturing-process","text":"Each TPM must be individually manufactured. This consists of committing vendor certificate for TPM's primary Endorsement Key (EK) to its nonvolatile memory. As each EK is unique, so is its certificate, and it must be sign by key which chain of trust is rooted in publicly available vendor's root certificate. Milestones: create manufacturing process post the process on the documentation site create script for automation of manufacturing process review and update existing documentation, add entry to changelog State: Backlog","title":"11. Manufacturing process"},{"location":"roadmap/#12-customizable-configuration","text":"Platforms other than the reference one may support different functionalities, or may have limited performance. To make transition to different hardware easier, some options should be made configurable. This may include available hash algorithms in TPM stack, physical interface used (LPC or SPI), presence of hardware RNG engine, amount of nonvolatile memory. Milestones: create easy to use build system integrating whole stack prepare configuration file for whole project review and update existing documentation, add entry to changelog State: In progress","title":"12. Customizable configuration"},{"location":"tutorials/","text":"Tutorials This section of documentation contains step-by-steps tutorials to help outline what TwPM is capable of while helping you achieving specific aims, such as building, or flashing the TwPM project to the development board. Document Goal Building TwPM Learn how to build the TwPM project Mainboard connection Learn how to connect the TwPM to your platform","title":"Index"},{"location":"tutorials/#tutorials","text":"This section of documentation contains step-by-steps tutorials to help outline what TwPM is capable of while helping you achieving specific aims, such as building, or flashing the TwPM project to the development board. Document Goal Building TwPM Learn how to build the TwPM project Mainboard connection Learn how to connect the TwPM to your platform","title":"Tutorials"},{"location":"tutorials/building/","text":"Building TwPM This document serves as a starting point for building and flashing TwPM. Build and flashing instructions are available in TwPM_Toplevel repository.","title":"Building TwPM"},{"location":"tutorials/building/#building-twpm","text":"This document serves as a starting point for building and flashing TwPM. Build and flashing instructions are available in TwPM_Toplevel repository.","title":"Building TwPM"},{"location":"tutorials/mainboard-connection/","text":"Connecting TwPM to mainboard This document describes how TwPM can be connected to the mainboard. WARNING The TPM header is not standardized, make sure that you're using proper pinout for your mainboard. Just because it physically looks identical (even including key that is supposed to make connection of bad TPM type impossible) doesn't mean it has the same signals on the same pins. The pinout is usually described in the mainboard's manual, refer to it before attempting to connect the module. Wrong connection may break your TPM, mainboard, or both. We do not take responsibility for potential damage caused by it. You have been warned. Pinout for TwPM based on OrangeCrab This is valid for TwPM built for OrangeCrab from release v0.3.0. Pinout from official documentation : Unfortunately, there are many different labels assigned to each pin. Each of the types of identification is important to different group of people, or for different tasks. The table below maps signal names to physical pin numbers (i.e. as they are described in .lpf files, this is what FPGA tools need) and I/O numbers (i.e. what is printed on the board, you will most likely use this to find the correct pin). In addition to signals for exchanging data with the mainboard, 3V3 and GND must also be connected to supply power to the OrangeCrab. If those pins need to be changed for any reason, it can be done in orangecrab.lpf file . Remember to change SITE of given signal to another physical pin, not only the comment which contains I/O number. For OrangeCrab, mapping between I/O pins and physical ports can be read from schematics . Note that only one of the below interfaces is enabled at any given time. Switching between them requires rebuilding and flashing the new bitstream. LPC Signal name Physical Pin I/O number LCLK H2 12 LRESET# J2 13 LFRAME# A8 11 LAD[0] B8 10 LAD[1] C8 9 LAD[2] B9 6 LAD[3] B10 5 SERIRQ C9 SCL SPI Signal name Physical Pin I/O number CLK H2 12 MISO J2 13 MOSI A8 11 CS_N B8 10 PIRQ C9 SCL Mainboard pinouts The presented list has only mainboards that are confirmed to be valid. You are free to try it on the boards not listed below, assuming you know what you're doing . Protectli VP46xx (LPC) Protectli platforms from VP46xx series have header compatible with TPM-01 . It is 2x10 pin header, with key on pin 4. It is dangerously similar to multiple Gigabyte and Supermicro TPMs, but their layout is different so those are not compatible. Pinout: Pin No. Definition Pin No. Definition 1 LCLK 2 GND 3 LAD0 4 key 5 LAD1 6 NC 7 LAD2 8 GND 9 LAD3 10 GND 11 LFRAME# 12 GND 13 LRESET# 14 NC 15 NC 16 NC 17 GND 18 VDD (3.3V) 19 SERIRQ 20 NC Some of the NC pins are actually used for other purposes. For clarity and to avoid making mistakes they are not marked above. Protectli VP66xx (SPI) Protectli platforms from VP66xx series have header compatible with TPM-02 . It is 2x6 pin header, with key on pin 10, and a pitch different than OrangeCrab (2.00 mm instead of 2.54 mm), make sure you have proper wiring. The header is the same as on some of the MSI boards. Gigabyte uses rotated version of this pinout, while it looks the same, the pinout is different. Pinout: Pin No. Definition Pin No. Definition 1 VDD (3.3V) 2 CS_N 3 MISO 4 MOSI 5 NC 6 CLK 7 GND 8 NC 9 NC 10 key 11 NC 12 PIRQ Some of the NC pins are actually used for other purposes. For clarity and to avoid making mistakes they are not marked above.","title":"Connecting TwPM to the mainboard"},{"location":"tutorials/mainboard-connection/#connecting-twpm-to-mainboard","text":"This document describes how TwPM can be connected to the mainboard.","title":"Connecting TwPM to mainboard"},{"location":"tutorials/mainboard-connection/#warning","text":"The TPM header is not standardized, make sure that you're using proper pinout for your mainboard. Just because it physically looks identical (even including key that is supposed to make connection of bad TPM type impossible) doesn't mean it has the same signals on the same pins. The pinout is usually described in the mainboard's manual, refer to it before attempting to connect the module. Wrong connection may break your TPM, mainboard, or both. We do not take responsibility for potential damage caused by it. You have been warned.","title":"WARNING"},{"location":"tutorials/mainboard-connection/#pinout-for-twpm-based-on-orangecrab","text":"This is valid for TwPM built for OrangeCrab from release v0.3.0. Pinout from official documentation : Unfortunately, there are many different labels assigned to each pin. Each of the types of identification is important to different group of people, or for different tasks. The table below maps signal names to physical pin numbers (i.e. as they are described in .lpf files, this is what FPGA tools need) and I/O numbers (i.e. what is printed on the board, you will most likely use this to find the correct pin). In addition to signals for exchanging data with the mainboard, 3V3 and GND must also be connected to supply power to the OrangeCrab. If those pins need to be changed for any reason, it can be done in orangecrab.lpf file . Remember to change SITE of given signal to another physical pin, not only the comment which contains I/O number. For OrangeCrab, mapping between I/O pins and physical ports can be read from schematics . Note that only one of the below interfaces is enabled at any given time. Switching between them requires rebuilding and flashing the new bitstream.","title":"Pinout for TwPM based on OrangeCrab"},{"location":"tutorials/mainboard-connection/#mainboard-pinouts","text":"The presented list has only mainboards that are confirmed to be valid. You are free to try it on the boards not listed below, assuming you know what you're doing .","title":"Mainboard pinouts"}]}